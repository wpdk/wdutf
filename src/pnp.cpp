/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2014, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Plug and Play Routines.
 */

#include "stdddk.h"


DRIVER_INITIALIZE DdkPnpDriverEntry;
DRIVER_UNLOAD DdkPnpDriverUnload;
DRIVER_DISPATCH DdkPnpDispatch;

NTSTATUS DdkPnpIssueRequest(PDEVICE_OBJECT DeviceObject, UCHAR Request, PIRP Irp = NULL);
NTSTATUS DdkPnpRemoveDevice(PDEVICE_OBJECT DeviceObject, bool force);
NTSTATUS DdkPnpStartDevice(PDEVICE_OBJECT DeviceObject);


static PDRIVER_OBJECT DdkPnpManager;


void DdkPnpInit()
{
	if (!NT_SUCCESS(DdkInitDriver("PnpManager", DdkPnpDriverEntry)))
		ddkfail("Unable to create PnP Manager");
}


NTSTATUS DdkPnpCreateDevice(PDRIVER_OBJECT DriverObject)
{
	PDEVICE_OBJECT DeviceObject;

	if (!DriverObject->DriverExtension->AddDevice)
		return STATUS_SUCCESS;

	NTSTATUS status = IoCreateDevice(DdkPnpManager, 0, NULL, FILE_DEVICE_CONTROLLER,
		FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &DeviceObject);

	if (!NT_SUCCESS(status))
		return status;

	status = DriverObject->DriverExtension->AddDevice(DriverObject, DeviceObject);

	if (!NT_SUCCESS(status)) {
		IoDeleteDevice(DeviceObject);
		return status;
	}

	return DdkPnpStartDevice(IoGetAttachedDevice(DeviceObject));
}


void DdkPnpUnload(PDRIVER_OBJECT DriverObject)
{
	PDEVICE_OBJECT DeviceObject = DriverObject->DeviceObject;

	while (DeviceObject) {
		PDEVICE_OBJECT pDevice = IoGetDeviceAttachmentBaseRef(DeviceObject);

		if (pDevice->DriverObject == DdkPnpManager) {
			DdkPnpRemoveDevice(DeviceObject, true);
			DeviceObject = DriverObject->DeviceObject;
		}

		else DeviceObject = DeviceObject->NextDevice;
		ObDereferenceObject(pDevice);
	}
}


NTSTATUS DdkPnpStartDevice(PDEVICE_OBJECT DeviceObject)
{
	CM_RESOURCE_LIST list;
	PIRP Irp;

	if ((Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE)) == NULL)
 		return STATUS_INSUFFICIENT_RESOURCES;

	list.Count = 1;
	list.List[0].InterfaceType = InterfaceTypeUndefined;
	list.List[0].BusNumber = 0;
	list.List[0].PartialResourceList.Version = 1;
	list.List[0].PartialResourceList.Revision = 1;
	list.List[0].PartialResourceList.Count = 0;

	PIO_STACK_LOCATION pStack = IoGetNextIrpStackLocation(Irp);
	pStack->Parameters.StartDevice.AllocatedResources = &list;

	NTSTATUS status = DdkPnpIssueRequest(DeviceObject, IRP_MN_START_DEVICE, Irp);

	if (!NT_SUCCESS(status))
		DdkPnpIssueRequest(DeviceObject, IRP_MN_REMOVE_DEVICE);

	return status;
}


NTSTATUS DdkPnpRemoveDevice(PDEVICE_OBJECT DeviceObject, bool force)
{
	NTSTATUS status = DdkPnpIssueRequest(DeviceObject, IRP_MN_QUERY_REMOVE_DEVICE);

	if (!NT_SUCCESS(status) && !force) {
		DdkPnpIssueRequest(DeviceObject, IRP_MN_CANCEL_REMOVE_DEVICE);
		return status;
	}

	if (!NT_SUCCESS(status))
		DdkPnpIssueRequest(DeviceObject, IRP_MN_SURPRISE_REMOVAL);
	
	return DdkPnpIssueRequest(DeviceObject, IRP_MN_REMOVE_DEVICE);
}


NTSTATUS DdkPnpIssueRequest(PDEVICE_OBJECT DeviceObject, UCHAR Request, PIRP Irp)
{
	PDEVICE_OBJECT pDevice = IoGetAttachedDevice(DeviceObject);

	return DdkSynchronousIrp(pDevice, IRP_MJ_PNP, Request, Irp);
}


static NTSTATUS DdkPnpDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
	for (ULONG i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
		DriverObject->MajorFunction[i] = DdkPnpDispatch;

	DriverObject->DriverUnload = DdkPnpDriverUnload;
	DdkPnpManager = DriverObject;
	return STATUS_SUCCESS;
}


static void DdkPnpDriverUnload(PDRIVER_OBJECT DriverObject)
{
	DdkPnpManager = NULL;
}


static NTSTATUS DdkPnpDispatch(DEVICE_OBJECT *pDevice, IRP *pIrp)
{
	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);
	NTSTATUS status = STATUS_SUCCESS;

	if (pStack->MajorFunction == IRP_MJ_PNP) {
		if (pStack->MinorFunction == IRP_MN_REMOVE_DEVICE)
		    IoDeleteDevice(pDevice);
	}

	pIrp->IoStatus.Status = status;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return status;
}
