/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *  Copyright (c) 2024, rtegrity ltd. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Device Routines.
 */

#include "stdddk.h"


typedef struct _DEVICE_OBJECT_POWER_EXTENSION {
	ULONG	unused;
} DEVOBJ_POWER, *PDEVOBJ_POWER;

typedef struct _DEVICE : public OBJECT {
	DEVICE_OBJECT Device;
	DEVOBJ_EXTENSION Extension;
	DEVOBJ_POWER Power;
	PWCH DeviceName;
} DEVICE, *PDEVICE;

static volatile LONG UniqueId = -1;


static PDEVICE GetDevice(OBJECT *pObj)
{
	if (!pObj || pObj->type != IoDeviceType)
		ddkfail("Invalid device specified");

	return static_cast<DEVICE *>(pObj);
}


DDKAPI
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize,
	PUNICODE_STRING DeviceName, DEVICE_TYPE DeviceType, ULONG DeviceCharacteristics,
	BOOLEAN Exclusive, PDEVICE_OBJECT *DeviceObject)
{
	DDKASSERT(KeGetCurrentIrql() <= APC_LEVEL);

	DEVICE *pDevice = (DEVICE *)DdkAllocObject(
		sizeof(DEVICE) + DeviceExtensionSize, IoDeviceType, true);

	if (!pDevice) return STATUS_INSUFFICIENT_RESOURCES;

	DDKASSERT(DriverObject);

	pDevice->Device.Type = IO_TYPE_DEVICE;
	pDevice->Device.Size = sizeof(DEVICE_OBJECT);
	pDevice->Device.ReferenceCount = 0;
	pDevice->Device.DriverObject = DriverObject;
	pDevice->Device.DeviceExtension = (PVOID)(pDevice+1);
	pDevice->Device.DeviceType = DeviceType;
	pDevice->Device.Characteristics = DeviceCharacteristics;
	pDevice->Device.AlignmentRequirement = FILE_BYTE_ALIGNMENT;
	pDevice->Device.StackSize = 1;
	pDevice->Device.DeviceObjectExtension = &pDevice->Extension;

	pDevice->Extension.Type = IO_TYPE_DEVICE_OBJECT_EXTENSION;
	pDevice->Extension.Size = sizeof(DEVOBJ_EXTENSION);
	pDevice->Extension.DeviceObject = &pDevice->Device;
	pDevice->Extension.Dope = &pDevice->Power;

	if (DeviceName) {
		if (!DdkInsertName(DeviceName, pDevice, L"\\Device", &pDevice->DeviceName))
			return STATUS_OBJECT_NAME_EXISTS;
	}

	else if (DeviceCharacteristics & FILE_AUTOGENERATED_DEVICE_NAME) {
		UNICODE_STRING u;
		WCHAR buf[30];

		swprintf(buf, sizeof(buf) / sizeof(WCHAR),
			L"\\Device\\%08x", InterlockedIncrement(&UniqueId));
		RtlInitUnicodeString(&u, buf);

		if (!DdkInsertName(&u, pDevice, L"\\Device", &pDevice->DeviceName))
			return STATUS_OBJECT_NAME_EXISTS;
	}

	*DeviceObject = (PDEVICE_OBJECT)ToPointer(pDevice);

	DdkAddDevice(DriverObject, *DeviceObject);
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS IoGetDeviceObjectPointer(PUNICODE_STRING ObjectName,
	ACCESS_MASK DesiredAccess, PFILE_OBJECT *FileObject, PDEVICE_OBJECT *DeviceObject)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	IO_STATUS_BLOCK iostatus;
	OBJECT_ATTRIBUTES attr;
	HANDLE FileHandle;

	InitializeObjectAttributes(&attr, ObjectName, 0, NULL, NULL);

	// TODO - set correct flags

	NTSTATUS rc = IoCreateFile(&FileHandle, 0,
		&attr, &iostatus, NULL, 0, 0, 0, 0, NULL, NULL, CreateFileTypeNone, NULL, 0);

	if (!NT_SUCCESS(rc)) return rc;

	PFILE_OBJECT pFile = DdkGetFilePointer(FileHandle);

	*DeviceObject = IoGetRelatedDeviceObject(pFile);
	*FileObject = pFile;

	return STATUS_SUCCESS;
}


DDKAPI
VOID IoDeleteDevice(PDEVICE_OBJECT DeviceObject)
{
	DDKASSERT(KeGetCurrentIrql() <= APC_LEVEL);

	DEVICE *pDevice = GetDevice(FromPointer(DeviceObject));

	DdkRemoveObjectName(pDevice);
	DdkDereferenceObject(pDevice);
}


DDKAPI
NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject,
	CONST GUID *InterfaceClassGuid, PUNICODE_STRING ReferenceString, PUNICODE_STRING SymbolicLinkName)
{
	DEVICE *pDevice = GetDevice(FromPointer(PhysicalDeviceObject));
	UNICODE_STRING guid, link, path;

	DDKASSERT(InterfaceClassGuid);
	DDKASSERT(SymbolicLinkName);
	DDKASSERT(ReferenceString == NULL);

	// TODO - handle multiple registrations

	if (!pDevice->DeviceName)
		return STATUS_INVALID_DEVICE_REQUEST;

	if (!NT_SUCCESS(RtlStringFromGUID(*InterfaceClassGuid, &guid)))
		return STATUS_INVALID_DEVICE_REQUEST;

	DdkCreatePath(&link, &guid, L"\\??", L"ROOT#SYSTEM#0000#");
	RtlFreeUnicodeString(&guid);
	RtlInitUnicodeString(&path, pDevice->DeviceName);

	if (DdkIsDeviceInterface(&link, TRUE)) {
		*SymbolicLinkName = link;
		return STATUS_OBJECT_NAME_EXISTS;
	}

	IoDeleteSymbolicLink(&link);
	NTSTATUS status = IoCreateSymbolicLink(&link, &path);

	if (!NT_SUCCESS(status)) {
		RtlFreeUnicodeString(&link);
		return status;
	}

	IoSetDeviceInterfaceState(&link, FALSE);

	*SymbolicLinkName = link;
	return status;
}


DDKAPI
NTSTATUS IoGetDeviceInterfaces(CONST GUID *InterfaceClassGuid,
    PDEVICE_OBJECT PhysicalDeviceObject, ULONG Flags, PZZWSTR *SymbolicLinkList)
{
	BOOLEAN all = (Flags & DEVICE_INTERFACE_INCLUDE_NONACTIVE) != 0;
	UNICODE_STRING guid, link;

	DDKASSERT(InterfaceClassGuid);
	DDKASSERT(SymbolicLinkList);

	// TODO - handle multiple registrations

	if (!NT_SUCCESS(RtlStringFromGUID(*InterfaceClassGuid, &guid)))
		return STATUS_INVALID_DEVICE_REQUEST;

	DdkCreatePath(&link, &guid, L"\\??", L"ROOT#SYSTEM#0000#");
	RtlFreeUnicodeString(&guid);

	WCHAR *buf = (WCHAR *)ExAllocatePool(NonPagedPool, link.Length + sizeof(WCHAR) * 2);

	if (!buf) {
		RtlFreeUnicodeString(&link);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	memset(buf, 0, link.Length + sizeof(WCHAR) * 2);

	if (DdkIsDeviceInterface(&link, all))
		memcpy(buf, link.Buffer, link.Length);

	RtlFreeUnicodeString(&link);
	*SymbolicLinkList = buf;
	return STATUS_SUCCESS;
}


DDKAPI
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice,
	PDEVICE_OBJECT TargetDevice)
{
	PDEVICE_OBJECT pDevice;
	NTSTATUS status = IoAttachDeviceToDeviceStackSafe(SourceDevice, TargetDevice, &pDevice);
	return NT_SUCCESS(status) ? pDevice : NULL;
}


DDKAPI
NTSTATUS IoAttachDeviceToDeviceStackSafe(PDEVICE_OBJECT SourceDevice,
    PDEVICE_OBJECT TargetDevice, PDEVICE_OBJECT *AttachedToDeviceObject)
{
	PDEVICE_OBJECT pDevice = IoGetAttachedDevice(TargetDevice);

	SourceDevice->StackSize = pDevice->StackSize + 1;
	SourceDevice->AlignmentRequirement = pDevice->AlignmentRequirement;

	*AttachedToDeviceObject = pDevice;
	SourceDevice->DeviceObjectExtension->AttachedTo = pDevice;
	pDevice->AttachedDevice = SourceDevice;

	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS IoAttachDevice(PDEVICE_OBJECT SourceDevice,
	PUNICODE_STRING TargetDevice, PDEVICE_OBJECT *AttachedDevice)
{
	PFILE_OBJECT pFileObject;
	PDEVICE_OBJECT pDeviceObject;

	NTSTATUS status = IoGetDeviceObjectPointer(TargetDevice,
		FILE_READ_ATTRIBUTES, &pFileObject, &pDeviceObject);
	
	if (!NT_SUCCESS(status))
		return status;

	status = IoAttachDeviceToDeviceStackSafe(SourceDevice, pDeviceObject, AttachedDevice);

	ObDereferenceObject(pFileObject);
	return status;
}


DDKAPI
NTSTATUS IoAttachDeviceByPointer(PDEVICE_OBJECT SourceDevice,
    PDEVICE_OBJECT TargetDevice)
{
	PDEVICE_OBJECT pDevice;
	return IoAttachDeviceToDeviceStackSafe(SourceDevice, TargetDevice, &pDevice);
}


DDKAPI
VOID IoDetachDevice(PDEVICE_OBJECT TargetDevice)
{
	TargetDevice->AttachedDevice->DeviceObjectExtension->AttachedTo = NULL;
	TargetDevice->AttachedDevice = NULL;
}


DDKAPI
PDEVICE_OBJECT IoGetAttachedDevice(PDEVICE_OBJECT DeviceObject)
{
	PDEVICE_OBJECT pDevice = DeviceObject;

	while (pDevice->AttachedDevice)
		pDevice = pDevice->AttachedDevice;

	return pDevice;
}


DDKAPI
PDEVICE_OBJECT IoGetAttachedDeviceReference(PDEVICE_OBJECT DeviceObject)
{
	PDEVICE_OBJECT pDevice = IoGetAttachedDevice(DeviceObject);

	ObReferenceObject(pDevice);
	return pDevice;
}


DDKAPI
PDEVICE_OBJECT IoGetLowerDeviceObject(PDEVICE_OBJECT DeviceObject)
{
	PDEVICE_OBJECT pDevice = DeviceObject->DeviceObjectExtension->AttachedTo;

	if (pDevice) ObReferenceObject(pDevice);
	return pDevice;
}


DDKAPI
PDEVICE_OBJECT IoGetDeviceAttachmentBaseRef(PDEVICE_OBJECT DeviceObject)
{
	PDEVICE_OBJECT pDevice = DeviceObject;

	while (pDevice->DeviceObjectExtension->AttachedTo)
		pDevice = pDevice->DeviceObjectExtension->AttachedTo;

	ObReferenceObject(pDevice);
	return pDevice;
}


DDKAPI
VOID IoInitializeRemoveLockEx(PIO_REMOVE_LOCK Lock, ULONG AllocateTag,
    ULONG MaxLockedMinutes, ULONG HighWatermark, ULONG RemlockSize)
{
	memset(Lock, 0, RemlockSize);

	if (RemlockSize > sizeof(Lock->Common)) {
		IO_REMOVE_LOCK_DBG_BLOCK *pDbg =
			(IO_REMOVE_LOCK_DBG_BLOCK *)((ULONG_PTR)Lock + sizeof(Lock->Common));

		KeInitializeSpinLock(&pDbg->Spin);
		InitializeListHead(&pDbg->LockList);
		pDbg->AllocateTag = AllocateTag;
		pDbg->HighWatermark = HighWatermark;
		pDbg->MaxLockedTicks = (MaxLockedMinutes * 600000000I64) / KeQueryTimeIncrement();
	}

	Lock->Common.IoCount = 1;
	KeInitializeEvent(&Lock->Common.RemoveEvent, NotificationEvent, FALSE);
}


DDKAPI
NTSTATUS IoAcquireRemoveLockEx(PIO_REMOVE_LOCK RemoveLock,
	PVOID Tag, PCSTR File, ULONG Line, ULONG RemlockSize)
{
	InterlockedIncrement(&RemoveLock->Common.IoCount);

	if (RemoveLock->Common.Removed) {
		if (InterlockedDecrement(&RemoveLock->Common.IoCount) == 0)
			KeSetEvent(&RemoveLock->Common.RemoveEvent, IO_NO_INCREMENT, FALSE);

		return STATUS_DELETE_PENDING;
	}

	return STATUS_SUCCESS;
}


DDKAPI
VOID IoReleaseRemoveLockEx(PIO_REMOVE_LOCK RemoveLock, PVOID Tag, ULONG RemlockSize)
{
	if (InterlockedDecrement(&RemoveLock->Common.IoCount) == 0)
		KeSetEvent(&RemoveLock->Common.RemoveEvent, IO_NO_INCREMENT, FALSE);
}


DDKAPI
VOID IoReleaseRemoveLockAndWaitEx(PIO_REMOVE_LOCK RemoveLock, PVOID Tag, ULONG RemlockSize)
{
	RemoveLock->Common.Removed = TRUE;
	InterlockedDecrement(&RemoveLock->Common.IoCount);

	if (InterlockedDecrement(&RemoveLock->Common.IoCount) > 0)
		KeWaitForSingleObject(&RemoveLock->Common.RemoveEvent, Executive, KernelMode, FALSE, 0);
}


void DdkFreeDeviceObject(OBJECT *pObj)
{
	PDEVICE_OBJECT DeviceObject = (PDEVICE_OBJECT)ToPointer(pObj);
	DdkRemoveDevice(DeviceObject->DriverObject, DeviceObject);
}
